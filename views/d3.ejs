<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<style>
		body {
			height: 100vh;
			margin: 0;
		}

		text {
			font-family: sans-serif;
			font-size: 10px;
		}

		svg {
			width: 100%;
			height: 100%;
		}
	</style>
	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<body>

	<svg></svg>
	
	<script>
		var width  = 1280;
		var height = 720;
		var svg    = d3.select("svg");
		var simulation;

		function dragstarted(d) {
			if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}

		function dragged(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function dragended(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		function loadData() {
			$.ajax({
				method: 'GET',
				url: '/data',
				success: function (data) {
					graph = data.d3data;
					console.log(graph);

					simulation = d3.forceSimulation(graph.nodes)
					.force("link", d3.forceLink().id(function (d) {
						return d.id;
					}))
					.force("charge", d3.forceManyBody())
					.force("center", d3.forceCenter(width / 2, height / 2));

					var opacity = 2 / (2 + Math.sqrt(graph.links.length) / 32);
					console.log("opacity:" + opacity);
					var link = svg.append("g")
						.attr("class", "links")
						.selectAll("line")
						.data(graph.links)
						.enter().append("line")
						.attr("stroke-opacity", function (d) {
							return d.intersect_ratio * 0.85 + 0.15;
						})
						/*.attr("display", function (d) {
							if (d.intersect_ratio < 0.25) return "none";
							else return "";
						})*/
						.attr("stroke-width", function (d) {
							return Math.sqrt(d.intersect) + 1;
						})
						.attr("stroke", function (d) {
							var rank = 1 - d.intersect_ratio;
							var r = Math.sqrt(1 - rank) * 255;
							//var g = (rank >= 0.25 && rank < 0.5) ? (rank - 0.25) * 4 * 255
							//		: ((rank >= 0.5 && rank <= 0.75) ? (0.75 - rank) * 4 * 255 : 0);
							var g = (rank < 0.2) ? 0 : ((rank < 0.6) ? rank / 0.6 * 240 : Math.sqrt((1 - rank) / 0.4) * 240);
							var b = (rank > 0.5) ? (rank - 0.5) / 0.5 * 255 : 0;
							
							return "rgb(" + Math.floor(r) + "," + Math.floor(g) +","+ Math.floor(b) + ")";
						});

					var node = svg.append("g")
						.attr("class", "nodes")
						.selectAll("circle")
						.data(graph.nodes)
						.enter().append("circle")
						.attr("r", function(d) { return Math.log(d.size + 1) + 0.5; })
						.attr("fill", () => "#aa0000")
						.call(d3.drag()
							.on("start", dragstarted)
							.on("drag", dragged)
							.on("end", dragended)
						);

					svg.call(d3.zoom()
						//.extent([[0, 0], [width, height]])
						.scaleExtent([0.001, 100])
						.on("zoom", function () {
							svg.selectAll("g").attr("transform", d3.event.transform);
						}));

					/*var lables = node.append("text")
						.text(function (d) {
							return d.id;
						})
						.attr('x', 6)
						.attr('y', 3);*/

					node.append("title")
						.text(function (d) {
							return d.id;
						});

					simulation
						.on("tick", ticked);

					simulation.force("link")
						.links(graph.links);

					function ticked() {
						link
							.attr("x1", function (d) { return d.source.x; })
							.attr("y1", function (d) { return d.source.y; })
							.attr("x2", function (d) { return d.target.x; })
							.attr("y2", function (d) { return d.target.y; });

						node
							.attr("cx", function (d) { return d.x; })
							.attr("cy", function (d) { return d.y; });
					}

				}
			});
		}

		loadData();
	</script>
</body>

</html>